---
import ThemeToggle from '../components/ThemeToggle.jsx';
/* Simple server-rendered header with accessible theme toggle.
   No framework needed; script runs in the browser to toggle theme. */
---
<header class="site-header" role="banner">
  <div class="site-header-inner container">
    <div class="brand">
      <a href="/" class="logo">VoidTales Gallery</a>
    </div>

    <div class="header-actions" role="navigation" aria-label="Site controls">
      <ThemeToggle client:load />
    </div>
  </div>

  <style>
    .site-header {
      position: relative;
      z-index: 20; /* above background */
      background: rgba(255,255,255,0.0); /* transparent */
      padding: 10px 0;
      border-bottom: 0;
    }
    .site-header-inner {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
    }
    .brand .logo {
      font-weight:600;
      text-decoration:none;
      color:inherit;
      font-size:1.1rem;
    }

    .theme-toggle{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:8px;
      border:1px solid rgba(0,0,0,0.06);
      background: rgba(255,255,255,0.6);
      color: inherit;
      cursor:pointer;
      font-size:0.95rem;
    }
    .theme-toggle:focus{
      outline:2px solid #2563eb;
      outline-offset:2px;
    }
    /* dark mode visual tweaks */
    html.dark .theme-toggle{
      background: rgba(0,0,0,0.35);
      border-color: rgba(255,255,255,0.06);
    }
    .theme-toggle .icon { display:inline-flex; align-items:center; justify-content:center; }
    .theme-toggle .label { display:inline-block; min-width:38px; text-align:left; }
    @media (max-width:600px){
      .theme-toggle .label { display:none; }
      .site-header-inner { padding:0 6px; }
    }
  </style>

  <script>
    (function(){
    const btn = document.getElementById('theme-toggle');
    if (!btn) return;

    function getSaved() {
      try { return localStorage.getItem('saved-theme'); } catch(e) { return null; }
    }

    function getSystemPref() {
      return (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) ? 'dark' : 'light';
    }

    function getCurrentTheme(){
      const attr = document.documentElement.getAttribute('data-color-mode');
      if (attr) return attr;
      return document.documentElement.classList.contains('dark') ? 'dark' : 'light';
    }

    function applyTheme(theme: 'dark' | 'light'){
      if (theme === 'dark') document.documentElement.classList.add('dark');
      else document.documentElement.classList.remove('dark');
      document.documentElement.setAttribute('data-color-mode', theme);
      document.documentElement.setAttribute('data-theme', theme);
      document.documentElement.setAttribute('saved-theme', theme);
      updateButton(theme);
    }

    function setTheme(theme: 'dark' | 'light'){
      applyTheme(theme);
      try { localStorage.setItem('saved-theme', theme); } catch(e){ /* ignore */ }
    }

    function updateButton(theme: 'dark' | 'light'){
      const pressed = theme === 'dark';
      if (!btn) return;
      btn.setAttribute('aria-pressed', pressed ? 'true' : 'false');
      const sun = btn.querySelector('.icon.sun') as HTMLElement | null;
      const moon = btn.querySelector('.icon.moon') as HTMLElement | null;
      const label = btn.querySelector('.label');
      if (sun) sun.style.display = pressed ? 'none' : 'inline-flex';
      if (moon) moon.style.display = pressed ? 'inline-flex' : 'none';
      if (label) label.textContent = pressed ? 'Dark' : 'Light';
    }

    // initialize: prefer saved, else system
    const initialRaw = getSaved() || getSystemPref();
    const initial = initialRaw === 'dark' ? 'dark' : 'light';
    applyTheme(initial);

    // click handler
    btn.addEventListener('click', () => {
      const next = getCurrentTheme() === 'dark' ? 'light' : 'dark';
      setTheme(next);
    });
    btn.addEventListener('keydown', (e) => {
      if (e.key === ' ' || e.key === 'Enter') {
        e.preventDefault();
        btn.click();
      }
    });

    // Re-apply theme when window regains focus (covers HMR DOM swaps)
    window.addEventListener('focus', () => {
      const saved = getSaved();
      if (saved === 'dark' || saved === 'light') applyTheme(saved);
    });

    // Sync across tabs/windows
    window.addEventListener('storage', (e) => {
      if (e.key === 'saved-theme') {
        const v = e.newValue || getSystemPref();
        if (v === 'dark' || v === 'light') {
          applyTheme(v);
        }
      }
    });

    // Optional: observe html attrs in case another script mutates them
    const obs = new MutationObserver(() => {
      const theme = getCurrentTheme();
      if (theme === 'dark' || theme === 'light') {
        updateButton(theme);
      }
    });
    obs.observe(document.documentElement, { attributes: true, attributeFilter: ['class','data-color-mode','data-theme','saved-theme'] });

    // HMR hint: if import.meta.hot exists (module is hot), accept and reapply saved theme
    try {
      if (import.meta && import.meta.hot) {
        import.meta.hot.accept(() => {
          const saved = getSaved() || getSystemPref();
          if (saved === 'dark' || saved === 'light') {
            applyTheme(saved);
          }
        });
      }
    } catch (e) {
      // import.meta.hot may not be available in inline script; ignore
    }

  })();
  </script>
</header>
